#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]

pub const AI_MAX_NUMBER_OF_COLOR_SETS: usize = 0x8;
pub const AI_MAX_NUMBER_OF_TEXTURECOORDS: usize = 0x8;

// automatically generated by rust-bindgen

pub type __u_char = ::libc::c_uchar;
pub type __u_short = ::libc::c_ushort;
pub type __u_int = ::libc::c_uint;
pub type __u_long = ::libc::c_ulong;
pub type __int8_t = ::libc::c_char;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
pub type __uint64_t = ::libc::c_ulong;
pub type __quad_t = ::libc::c_long;
pub type __u_quad_t = ::libc::c_ulong;
pub type __dev_t = ::libc::c_ulong;
pub type __uid_t = ::libc::c_uint;
pub type __gid_t = ::libc::c_uint;
pub type __ino_t = ::libc::c_ulong;
pub type __ino64_t = ::libc::c_ulong;
pub type __mode_t = ::libc::c_uint;
pub type __nlink_t = ::libc::c_ulong;
pub type __off_t = ::libc::c_long;
pub type __off64_t = ::libc::c_long;
pub type __pid_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __fsid_t {
    pub __val: [::libc::c_int; 2usize],
}
impl ::std::default::Default for __fsid_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __clock_t = ::libc::c_long;
pub type __rlim_t = ::libc::c_ulong;
pub type __rlim64_t = ::libc::c_ulong;
pub type __id_t = ::libc::c_uint;
pub type __time_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_uint;
pub type __suseconds_t = ::libc::c_long;
pub type __daddr_t = ::libc::c_int;
pub type __key_t = ::libc::c_int;
pub type __clockid_t = ::libc::c_int;
pub type __timer_t = *mut ::libc::c_void;
pub type __blksize_t = ::libc::c_long;
pub type __blkcnt_t = ::libc::c_long;
pub type __blkcnt64_t = ::libc::c_long;
pub type __fsblkcnt_t = ::libc::c_ulong;
pub type __fsblkcnt64_t = ::libc::c_ulong;
pub type __fsfilcnt_t = ::libc::c_ulong;
pub type __fsfilcnt64_t = ::libc::c_ulong;
pub type __fsword_t = ::libc::c_long;
pub type __ssize_t = ::libc::c_long;
pub type __syscall_slong_t = ::libc::c_long;
pub type __syscall_ulong_t = ::libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::libc::c_char;
pub type __intptr_t = ::libc::c_long;
pub type __socklen_t = ::libc::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = isize;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type size_t = usize;
pub type ulong = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint_ = ::libc::c_uint;
pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;
pub type u_int8_t = ::libc::c_uchar;
pub type u_int16_t = ::libc::c_ushort;
pub type u_int32_t = ::libc::c_uint;
pub type u_int64_t = ::libc::c_ulong;
pub type register_t = ::libc::c_long;
pub type __sig_atomic_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __sigset_t {
    pub __val: [::libc::c_ulong; 16usize],
}
impl ::std::default::Default for __sigset_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
impl ::std::default::Default for timespec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
impl ::std::default::Default for timeval {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::libc::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
impl ::std::default::Default for fd_set {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::libc::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_attr_t {
    pub _bindgen_data_: [u64; 7usize],
}
impl pthread_attr_t {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_attr_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
impl ::std::default::Default for __pthread_internal_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_mutex_t {
    pub _bindgen_data_: [u64; 5usize],
}
impl pthread_mutex_t {
    pub unsafe fn __data(&mut self) -> *mut __pthread_mutex_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 40usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_mutex_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __pthread_mutex_s {
    pub __lock: ::libc::c_int,
    pub __count: ::libc::c_uint,
    pub __owner: ::libc::c_int,
    pub __nusers: ::libc::c_uint,
    pub __kind: ::libc::c_int,
    pub __spins: ::libc::c_short,
    pub __elision: ::libc::c_short,
    pub __list: __pthread_list_t,
}
impl ::std::default::Default for __pthread_mutex_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_mutexattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_mutexattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_mutexattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct pthread_cond_t {
    pub _bindgen_data_: [u64; 6usize],
}
impl pthread_cond_t {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed1 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 48usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_cond_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed1 {
    pub __lock: ::libc::c_int,
    pub __futex: ::libc::c_uint,
    pub __total_seq: ::libc::c_ulonglong,
    pub __wakeup_seq: ::libc::c_ulonglong,
    pub __woken_seq: ::libc::c_ulonglong,
    pub __mutex: *mut ::libc::c_void,
    pub __nwaiters: ::libc::c_uint,
    pub __broadcast_seq: ::libc::c_uint,
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_condattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_condattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_condattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_key_t = ::libc::c_uint;
pub type pthread_once_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_rwlock_t {
    pub _bindgen_data_: [u64; 7usize],
}
impl pthread_rwlock_t {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed2 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_rwlock_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed2 {
    pub __lock: ::libc::c_int,
    pub __nr_readers: ::libc::c_uint,
    pub __readers_wakeup: ::libc::c_uint,
    pub __writer_wakeup: ::libc::c_uint,
    pub __nr_readers_queued: ::libc::c_uint,
    pub __nr_writers_queued: ::libc::c_uint,
    pub __writer: ::libc::c_int,
    pub __shared: ::libc::c_int,
    pub __rwelision: ::libc::c_char,
    pub __pad1: [::libc::c_uchar; 7usize],
    pub __pad2: ::libc::c_ulong,
    pub __flags: ::libc::c_uint,
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_rwlockattr_t {
    pub _bindgen_data_: [u64; 1usize],
}
impl pthread_rwlockattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_rwlockattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_spinlock_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_barrier_t {
    pub _bindgen_data_: [u64; 4usize],
}
impl pthread_barrier_t {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_barrier_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_barrierattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_barrierattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_barrierattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type float_t = ::libc::c_float;
pub type double_t = ::libc::c_double;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed3 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4,
}
#[derive(Copy, Clone)]
#[repr(i32)]
#[derive(Debug)]
pub enum _LIB_VERSION_TYPE {
    _IEEE_ = -1,
    _SVID_ = 0,
    _XOPEN_ = 1,
    _POSIX_ = 2,
    _ISOC_ = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct exception {
    pub type_: ::libc::c_int,
    pub name: *mut ::libc::c_char,
    pub arg1: ::libc::c_double,
    pub arg2: ::libc::c_double,
    pub retval: ::libc::c_double,
}
impl ::std::default::Default for exception {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ptrdiff_t = isize;
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __clang_max_align_nonce2: ::libc::c_double,
}
impl ::std::default::Default for max_align_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum __locale_data { }
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::libc::c_ushort,
    pub __ctype_tolower: *const ::libc::c_int,
    pub __ctype_toupper: *const ::libc::c_int,
    pub __names: [*const ::libc::c_char; 13usize],
}
impl ::std::default::Default for __locale_struct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
#[repr(C, packed)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiVector3D {
    pub x: ::libc::c_float,
    pub y: ::libc::c_float,
    pub z: ::libc::c_float,
}
impl ::std::default::Default for aiVector3D {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiVector2D {
    pub x: ::libc::c_float,
    pub y: ::libc::c_float,
}
impl ::std::default::Default for aiVector2D {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiColor4D {
    pub r: ::libc::c_float,
    pub g: ::libc::c_float,
    pub b: ::libc::c_float,
    pub a: ::libc::c_float,
}
impl ::std::default::Default for aiColor4D {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiMatrix3x3 {
    pub a1: ::libc::c_float,
    pub a2: ::libc::c_float,
    pub a3: ::libc::c_float,
    pub b1: ::libc::c_float,
    pub b2: ::libc::c_float,
    pub b3: ::libc::c_float,
    pub c1: ::libc::c_float,
    pub c2: ::libc::c_float,
    pub c3: ::libc::c_float,
}
impl ::std::default::Default for aiMatrix3x3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiMatrix4x4 {
    pub a1: ::libc::c_float,
    pub a2: ::libc::c_float,
    pub a3: ::libc::c_float,
    pub a4: ::libc::c_float,
    pub b1: ::libc::c_float,
    pub b2: ::libc::c_float,
    pub b3: ::libc::c_float,
    pub b4: ::libc::c_float,
    pub c1: ::libc::c_float,
    pub c2: ::libc::c_float,
    pub c3: ::libc::c_float,
    pub c4: ::libc::c_float,
    pub d1: ::libc::c_float,
    pub d2: ::libc::c_float,
    pub d3: ::libc::c_float,
    pub d4: ::libc::c_float,
}
impl ::std::default::Default for aiMatrix4x4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiQuaternion {
    pub w: ::libc::c_float,
    pub x: ::libc::c_float,
    pub y: ::libc::c_float,
    pub z: ::libc::c_float,
}
impl ::std::default::Default for aiQuaternion {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiPlane {
    pub a: ::libc::c_float,
    pub b: ::libc::c_float,
    pub c: ::libc::c_float,
    pub d: ::libc::c_float,
}
impl ::std::default::Default for aiPlane {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiRay {
    pub pos: aiVector3D,
    pub dir: aiVector3D,
}
impl ::std::default::Default for aiRay {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiColor3D {
    pub r: ::libc::c_float,
    pub g: ::libc::c_float,
    pub b: ::libc::c_float,
}
impl ::std::default::Default for aiColor3D {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct aiString {
    pub length: size_t,
    pub data: [::libc::c_char; 1024usize],
}
impl ::std::clone::Clone for aiString {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiString {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[derive(Copy, Clone)]
#[repr(i32)]
#[derive(Debug, PartialEq, Eq)]
pub enum aiReturn {
    aiReturn_SUCCESS = 0,
    aiReturn_FAILURE = -1,
    aiReturn_OUTOFMEMORY = -3,
    _AI_ENFORCE_ENUM_SIZE = 2147483647,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiOrigin {
    aiOrigin_SET = 0,
    aiOrigin_CUR = 1,
    aiOrigin_END = 2,
    _AI_ORIGIN_ENFORCE_ENUM_SIZE = 2147483647,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiDefaultLogStream {
    aiDefaultLogStream_FILE = 1,
    aiDefaultLogStream_STDOUT = 2,
    aiDefaultLogStream_STDERR = 4,
    aiDefaultLogStream_DEBUGGER = 8,
    _AI_DLS_ENFORCE_ENUM_SIZE = 2147483647,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiMemoryInfo {
    pub textures: ::libc::c_uint,
    pub materials: ::libc::c_uint,
    pub meshes: ::libc::c_uint,
    pub nodes: ::libc::c_uint,
    pub animations: ::libc::c_uint,
    pub cameras: ::libc::c_uint,
    pub lights: ::libc::c_uint,
    pub total: ::libc::c_uint,
}
impl ::std::default::Default for aiMemoryInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiImporterFlags {
    aiImporterFlags_SupportTextFlavour = 1,
    aiImporterFlags_SupportBinaryFlavour = 2,
    aiImporterFlags_SupportCompressedFlavour = 4,
    aiImporterFlags_LimitedSupport = 8,
    aiImporterFlags_Experimental = 16,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiImporterDesc {
    pub mName: *const ::libc::c_char,
    pub mAuthor: *const ::libc::c_char,
    pub mMaintainer: *const ::libc::c_char,
    pub mComments: *const ::libc::c_char,
    pub mFlags: ::libc::c_uint,
    pub mMinMajor: ::libc::c_uint,
    pub mMinMinor: ::libc::c_uint,
    pub mMaxMajor: ::libc::c_uint,
    pub mMaxMinor: ::libc::c_uint,
    pub mFileExtensions: *const ::libc::c_char,
}
impl ::std::default::Default for aiImporterDesc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum aiFileIO { }
pub type aiLogStreamCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::libc::c_char,
                                                  arg2: *mut ::libc::c_char)>;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiLogStream {
    pub callback: aiLogStreamCallback,
    pub user: *mut ::libc::c_char,
}
impl ::std::default::Default for aiLogStream {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiPropertyStore {
    pub sentinel: ::libc::c_char,
}
impl ::std::default::Default for aiPropertyStore {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type aiBool = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiExportFormatDesc {
    pub id: *const ::libc::c_char,
    pub description: *const ::libc::c_char,
    pub fileExtension: *const ::libc::c_char,
}
impl ::std::default::Default for aiExportFormatDesc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct aiExportDataBlob {
    pub size: size_t,
    pub data: *mut ::libc::c_void,
    pub name: aiString,
    pub next: *mut aiExportDataBlob,
}
impl ::std::clone::Clone for aiExportDataBlob {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiExportDataBlob {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiTexel {
    pub b: ::libc::c_uchar,
    pub g: ::libc::c_uchar,
    pub r: ::libc::c_uchar,
    pub a: ::libc::c_uchar,
}
impl ::std::default::Default for aiTexel {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiTexture {
    pub mWidth: ::libc::c_uint,
    pub mHeight: ::libc::c_uint,
    pub achFormatHint: [::libc::c_char; 4usize],
    pub pcData: *mut aiTexel,
}
impl ::std::default::Default for aiTexture {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiFace {
    pub mNumIndices: ::libc::c_uint,
    pub mIndices: *mut ::libc::c_uint,
}
impl ::std::default::Default for aiFace {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiVertexWeight {
    pub mVertexId: ::libc::c_uint,
    pub mWeight: ::libc::c_float,
}
impl ::std::default::Default for aiVertexWeight {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct aiBone {
    pub mName: aiString,
    pub mNumWeights: ::libc::c_uint,
    pub mWeights: *mut aiVertexWeight,
    pub mOffsetMatrix: aiMatrix4x4,
}
impl ::std::clone::Clone for aiBone {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiBone {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiPrimitiveType {
    aiPrimitiveType_POINT = 1,
    aiPrimitiveType_LINE = 2,
    aiPrimitiveType_TRIANGLE = 4,
    aiPrimitiveType_POLYGON = 8,
    _aiPrimitiveType_Force32Bit = 2147483647,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiAnimMesh {
    pub mVertices: *mut aiVector3D,
    pub mNormals: *mut aiVector3D,
    pub mTangents: *mut aiVector3D,
    pub mBitangents: *mut aiVector3D,
    pub mColors: [*mut aiColor4D; 8usize],
    pub mTextureCoords: [*mut aiVector3D; 8usize],
    pub mNumVertices: ::libc::c_uint,
}
impl ::std::default::Default for aiAnimMesh {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct aiMesh {
    pub mPrimitiveTypes: ::libc::c_uint,
    pub mNumVertices: ::libc::c_uint,
    pub mNumFaces: ::libc::c_uint,
    pub mVertices: *mut aiVector3D,
    pub mNormals: *mut aiVector3D,
    pub mTangents: *mut aiVector3D,
    pub mBitangents: *mut aiVector3D,
    pub mColors: [*mut aiColor4D; 8usize],
    pub mTextureCoords: [*mut aiVector3D; 8usize],
    pub mNumUVComponents: [::libc::c_uint; 8usize],
    pub mFaces: *mut aiFace,
    pub mNumBones: ::libc::c_uint,
    pub mBones: *mut *mut aiBone,
    pub mMaterialIndex: ::libc::c_uint,
    pub mName: aiString,
    pub mNumAnimMeshes: ::libc::c_uint,
    pub mAnimMeshes: *mut *mut aiAnimMesh,
}
impl ::std::clone::Clone for aiMesh {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiMesh {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiLightSourceType {
    aiLightSource_UNDEFINED = 0,
    aiLightSource_DIRECTIONAL = 1,
    aiLightSource_POINT = 2,
    aiLightSource_SPOT = 3,
    aiLightSource_AMBIENT = 4,
    aiLightSource_AREA = 5,
    _aiLightSource_Force32Bit = 2147483647,
}
#[repr(C)]
#[derive(Copy)]
pub struct aiLight {
    pub mName: aiString,
    pub mType: aiLightSourceType,
    pub mPosition: aiVector3D,
    pub mDirection: aiVector3D,
    pub mUp: aiVector3D,
    pub mAttenuationConstant: ::libc::c_float,
    pub mAttenuationLinear: ::libc::c_float,
    pub mAttenuationQuadratic: ::libc::c_float,
    pub mColorDiffuse: aiColor3D,
    pub mColorSpecular: aiColor3D,
    pub mColorAmbient: aiColor3D,
    pub mAngleInnerCone: ::libc::c_float,
    pub mAngleOuterCone: ::libc::c_float,
    pub mSize: aiVector2D,
}
impl ::std::clone::Clone for aiLight {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiLight {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct aiCamera {
    pub mName: aiString,
    pub mPosition: aiVector3D,
    pub mUp: aiVector3D,
    pub mLookAt: aiVector3D,
    pub mHorizontalFOV: ::libc::c_float,
    pub mClipPlaneNear: ::libc::c_float,
    pub mClipPlaneFar: ::libc::c_float,
    pub mAspect: ::libc::c_float,
    _bindgen_padding_0_: [u8; 4usize],
}
impl ::std::clone::Clone for aiCamera {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiCamera {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiTextureOp {
    aiTextureOp_Multiply = 0,
    aiTextureOp_Add = 1,
    aiTextureOp_Subtract = 2,
    aiTextureOp_Divide = 3,
    aiTextureOp_SmoothAdd = 4,
    aiTextureOp_SignedAdd = 5,
    _aiTextureOp_Force32Bit = 2147483647,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiTextureMapMode {
    aiTextureMapMode_Wrap = 0,
    aiTextureMapMode_Clamp = 1,
    aiTextureMapMode_Decal = 3,
    aiTextureMapMode_Mirror = 2,
    _aiTextureMapMode_Force32Bit = 2147483647,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiTextureMapping {
    aiTextureMapping_UV = 0,
    aiTextureMapping_SPHERE = 1,
    aiTextureMapping_CYLINDER = 2,
    aiTextureMapping_BOX = 3,
    aiTextureMapping_PLANE = 4,
    aiTextureMapping_OTHER = 5,
    _aiTextureMapping_Force32Bit = 2147483647,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiTextureType {
    aiTextureType_NONE = 0,
    aiTextureType_DIFFUSE = 1,
    aiTextureType_SPECULAR = 2,
    aiTextureType_AMBIENT = 3,
    aiTextureType_EMISSIVE = 4,
    aiTextureType_HEIGHT = 5,
    aiTextureType_NORMALS = 6,
    aiTextureType_SHININESS = 7,
    aiTextureType_OPACITY = 8,
    aiTextureType_DISPLACEMENT = 9,
    aiTextureType_LIGHTMAP = 10,
    aiTextureType_REFLECTION = 11,
    aiTextureType_UNKNOWN = 12,
    _aiTextureType_Force32Bit = 2147483647,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiShadingMode {
    aiShadingMode_Flat = 1,
    aiShadingMode_Gouraud = 2,
    aiShadingMode_Phong = 3,
    aiShadingMode_Blinn = 4,
    aiShadingMode_Toon = 5,
    aiShadingMode_OrenNayar = 6,
    aiShadingMode_Minnaert = 7,
    aiShadingMode_CookTorrance = 8,
    aiShadingMode_NoShading = 9,
    aiShadingMode_Fresnel = 10,
    _aiShadingMode_Force32Bit = 2147483647,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiTextureFlags {
    aiTextureFlags_Invert = 1,
    aiTextureFlags_UseAlpha = 2,
    aiTextureFlags_IgnoreAlpha = 4,
    _aiTextureFlags_Force32Bit = 2147483647,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiBlendMode {
    aiBlendMode_Default = 0,
    aiBlendMode_Additive = 1,
    _aiBlendMode_Force32Bit = 2147483647,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiUVTransform {
    pub mTranslation: aiVector2D,
    pub mScaling: aiVector2D,
    pub mRotation: ::libc::c_float,
}
impl ::std::default::Default for aiUVTransform {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiPropertyTypeInfo {
    aiPTI_Float = 1,
    aiPTI_String = 3,
    aiPTI_Integer = 4,
    aiPTI_Buffer = 5,
    _aiPTI_Force32Bit = 2147483647,
}
#[repr(C)]
#[derive(Copy)]
pub struct aiMaterialProperty {
    pub mKey: aiString,
    pub mSemantic: ::libc::c_uint,
    pub mIndex: ::libc::c_uint,
    pub mDataLength: ::libc::c_uint,
    pub mType: aiPropertyTypeInfo,
    pub mData: *mut ::libc::c_char,
}
impl ::std::clone::Clone for aiMaterialProperty {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiMaterialProperty {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiMaterial {
    pub mProperties: *mut *mut aiMaterialProperty,
    pub mNumProperties: ::libc::c_uint,
    pub mNumAllocated: ::libc::c_uint,
}
impl ::std::default::Default for aiMaterial {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiVectorKey {
    pub mTime: ::libc::c_double,
    pub mValue: aiVector3D,
    _bindgen_padding_0_: [u8; 4usize],
}
impl ::std::default::Default for aiVectorKey {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiQuatKey {
    pub mTime: ::libc::c_double,
    pub mValue: aiQuaternion,
}
impl ::std::default::Default for aiQuatKey {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiMeshKey {
    pub mTime: ::libc::c_double,
    pub mValue: ::libc::c_uint,
    _bindgen_padding_0_: [u8; 4usize],
}
impl ::std::default::Default for aiMeshKey {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiAnimBehaviour {
    aiAnimBehaviour_DEFAULT = 0,
    aiAnimBehaviour_CONSTANT = 1,
    aiAnimBehaviour_LINEAR = 2,
    aiAnimBehaviour_REPEAT = 3,
    _aiAnimBehaviour_Force32Bit = 2147483647,
}
#[repr(C)]
#[derive(Copy)]
pub struct aiNodeAnim {
    pub mNodeName: aiString,
    pub mNumPositionKeys: ::libc::c_uint,
    pub mPositionKeys: *mut aiVectorKey,
    pub mNumRotationKeys: ::libc::c_uint,
    pub mRotationKeys: *mut aiQuatKey,
    pub mNumScalingKeys: ::libc::c_uint,
    pub mScalingKeys: *mut aiVectorKey,
    pub mPreState: aiAnimBehaviour,
    pub mPostState: aiAnimBehaviour,
}
impl ::std::clone::Clone for aiNodeAnim {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiNodeAnim {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct aiMeshAnim {
    pub mName: aiString,
    pub mNumKeys: ::libc::c_uint,
    pub mKeys: *mut aiMeshKey,
}
impl ::std::clone::Clone for aiMeshAnim {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiMeshAnim {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct aiAnimation {
    pub mName: aiString,
    pub mDuration: ::libc::c_double,
    pub mTicksPerSecond: ::libc::c_double,
    pub mNumChannels: ::libc::c_uint,
    pub mChannels: *mut *mut aiNodeAnim,
    pub mNumMeshChannels: ::libc::c_uint,
    pub mMeshChannels: *mut *mut aiMeshAnim,
}
impl ::std::clone::Clone for aiAnimation {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiAnimation {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type uint8_t = u8;
pub type uint16_t = u16;
pub type uint32_t = u32;
pub type uint64_t = u64;
pub type int_least8_t = ::libc::c_char;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_char;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intptr_t = isize;
pub type uintptr_t = usize;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum aiMetadataType {
    AI_BOOL = 0,
    AI_INT = 1,
    AI_UINT64 = 2,
    AI_FLOAT = 3,
    AI_AISTRING = 4,
    AI_AIVECTOR3D = 5,
    FORCE_32BIT = 2147483647,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiMetadataEntry {
    pub mType: aiMetadataType,
    pub mData: *mut ::libc::c_void,
}
impl ::std::default::Default for aiMetadataEntry {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiMetadata {
    pub mNumProperties: ::libc::c_uint,
    pub mKeys: *mut aiString,
    pub mValues: *mut aiMetadataEntry,
}
impl ::std::default::Default for aiMetadata {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct aiNode {
    pub mName: aiString,
    pub mTransformation: aiMatrix4x4,
    pub mParent: *mut aiNode,
    pub mNumChildren: ::libc::c_uint,
    pub mChildren: *mut *mut aiNode,
    pub mNumMeshes: ::libc::c_uint,
    pub mMeshes: *mut ::libc::c_uint,
    pub mMetaData: *mut aiMetadata,
}
impl ::std::clone::Clone for aiNode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for aiNode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct aiScene {
    pub mFlags: ::libc::c_uint,
    pub mRootNode: *mut aiNode,
    pub mNumMeshes: ::libc::c_uint,
    pub mMeshes: *mut *mut aiMesh,
    pub mNumMaterials: ::libc::c_uint,
    pub mMaterials: *mut *mut aiMaterial,
    pub mNumAnimations: ::libc::c_uint,
    pub mAnimations: *mut *mut aiAnimation,
    pub mNumTextures: ::libc::c_uint,
    pub mTextures: *mut *mut aiTexture,
    pub mNumLights: ::libc::c_uint,
    pub mLights: *mut *mut aiLight,
    pub mNumCameras: ::libc::c_uint,
    pub mCameras: *mut *mut aiCamera,
    pub mPrivate: *mut ::libc::c_char,
}
impl ::std::default::Default for aiScene {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[link(name = "assimp", kind = "dylib")]
extern "C" {
    pub static mut signgam: ::libc::c_int;
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
}
#[link(name = "assimp", kind = "dylib")]
extern "C" {
    pub fn select(__nfds: ::libc::c_int,
                  __readfds: *mut fd_set,
                  __writefds: *mut fd_set,
                  __exceptfds: *mut fd_set,
                  __timeout: *mut timeval)
                  -> ::libc::c_int;
    pub fn pselect(__nfds: ::libc::c_int,
                   __readfds: *mut fd_set,
                   __writefds: *mut fd_set,
                   __exceptfds: *mut fd_set,
                   __timeout: *const timespec,
                   __sigmask: *const __sigset_t)
                   -> ::libc::c_int;
    pub fn gnu_dev_major(__dev: ::libc::c_ulonglong) -> ::libc::c_uint;
    pub fn gnu_dev_minor(__dev: ::libc::c_ulonglong) -> ::libc::c_uint;
    pub fn gnu_dev_makedev(__major: ::libc::c_uint,
                           __minor: ::libc::c_uint)
                           -> ::libc::c_ulonglong;
    pub fn acos(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __acos(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn asin(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __asin(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn atan(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __atan(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn atan2(__y: ::libc::c_double, __x: ::libc::c_double) -> ::libc::c_double;
    pub fn __atan2(__y: ::libc::c_double, __x: ::libc::c_double) -> ::libc::c_double;
    pub fn cos(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __cos(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn sin(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __sin(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn tan(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __tan(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn cosh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __cosh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn sinh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __sinh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn tanh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __tanh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn acosh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __acosh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn asinh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __asinh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn atanh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __atanh(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn exp(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __exp(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn frexp(__x: ::libc::c_double, __exponent: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn __frexp(__x: ::libc::c_double, __exponent: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn ldexp(__x: ::libc::c_double, __exponent: ::libc::c_int) -> ::libc::c_double;
    pub fn __ldexp(__x: ::libc::c_double, __exponent: ::libc::c_int) -> ::libc::c_double;
    pub fn log(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __log(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn log10(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __log10(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn modf(__x: ::libc::c_double, __iptr: *mut ::libc::c_double) -> ::libc::c_double;
    pub fn __modf(__x: ::libc::c_double, __iptr: *mut ::libc::c_double) -> ::libc::c_double;
    pub fn expm1(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __expm1(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn log1p(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __log1p(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn logb(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __logb(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn exp2(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __exp2(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn log2(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __log2(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn pow(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __pow(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn sqrt(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __sqrt(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn hypot(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __hypot(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn cbrt(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __cbrt(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn ceil(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __ceil(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn fabs(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __fabs(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn floor(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __floor(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn fmod(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __fmod(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __isinf(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn __finite(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn isinf(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn finite(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn drem(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __drem(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn significand(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __significand(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn copysign(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __copysign(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn nan(__tagb: *const ::libc::c_char) -> ::libc::c_double;
    pub fn __nan(__tagb: *const ::libc::c_char) -> ::libc::c_double;
    pub fn __isnan(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn isnan(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn j0(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __j0(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn j1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __j1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn jn(arg1: ::libc::c_int, arg2: ::libc::c_double) -> ::libc::c_double;
    pub fn __jn(arg1: ::libc::c_int, arg2: ::libc::c_double) -> ::libc::c_double;
    pub fn y0(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __y0(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn y1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __y1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn yn(arg1: ::libc::c_int, arg2: ::libc::c_double) -> ::libc::c_double;
    pub fn __yn(arg1: ::libc::c_int, arg2: ::libc::c_double) -> ::libc::c_double;
    pub fn erf(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __erf(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfc(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __erfc(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lgamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __lgamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tgamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __tgamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn gamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __gamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lgamma_r(arg1: ::libc::c_double, __signgamp: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn __lgamma_r(arg1: ::libc::c_double, __signgamp: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn rint(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __rint(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn nextafter(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __nextafter(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn nexttoward(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __nexttoward(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn remainder(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __remainder(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn scalbn(__x: ::libc::c_double, __n: ::libc::c_int) -> ::libc::c_double;
    pub fn __scalbn(__x: ::libc::c_double, __n: ::libc::c_int) -> ::libc::c_double;
    pub fn ilogb(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __ilogb(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn scalbln(__x: ::libc::c_double, __n: ::libc::c_long) -> ::libc::c_double;
    pub fn __scalbln(__x: ::libc::c_double, __n: ::libc::c_long) -> ::libc::c_double;
    pub fn nearbyint(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __nearbyint(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn round(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __round(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn trunc(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __trunc(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn remquo(__x: ::libc::c_double,
                  __y: ::libc::c_double,
                  __quo: *mut ::libc::c_int)
                  -> ::libc::c_double;
    pub fn __remquo(__x: ::libc::c_double,
                    __y: ::libc::c_double,
                    __quo: *mut ::libc::c_int)
                    -> ::libc::c_double;
    pub fn lrint(__x: ::libc::c_double) -> ::libc::c_long;
    pub fn __lrint(__x: ::libc::c_double) -> ::libc::c_long;
    pub fn llrint(__x: ::libc::c_double) -> ::libc::c_longlong;
    pub fn __llrint(__x: ::libc::c_double) -> ::libc::c_longlong;
    pub fn lround(__x: ::libc::c_double) -> ::libc::c_long;
    pub fn __lround(__x: ::libc::c_double) -> ::libc::c_long;
    pub fn llround(__x: ::libc::c_double) -> ::libc::c_longlong;
    pub fn __llround(__x: ::libc::c_double) -> ::libc::c_longlong;
    pub fn fdim(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __fdim(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn fmax(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __fmax(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn fmin(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __fmin(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __fpclassify(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn __signbit(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn fma(__x: ::libc::c_double,
               __y: ::libc::c_double,
               __z: ::libc::c_double)
               -> ::libc::c_double;
    pub fn __fma(__x: ::libc::c_double,
                 __y: ::libc::c_double,
                 __z: ::libc::c_double)
                 -> ::libc::c_double;
    pub fn scalb(__x: ::libc::c_double, __n: ::libc::c_double) -> ::libc::c_double;
    pub fn __scalb(__x: ::libc::c_double, __n: ::libc::c_double) -> ::libc::c_double;
    pub fn acosf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __acosf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn asinf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __asinf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn atanf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __atanf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn atan2f(__y: ::libc::c_float, __x: ::libc::c_float) -> ::libc::c_float;
    pub fn __atan2f(__y: ::libc::c_float, __x: ::libc::c_float) -> ::libc::c_float;
    pub fn cosf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __cosf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn sinf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __sinf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn tanf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __tanf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn coshf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __coshf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn sinhf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __sinhf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn tanhf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __tanhf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn acoshf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __acoshf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn asinhf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __asinhf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn atanhf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __atanhf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn expf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __expf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn frexpf(__x: ::libc::c_float, __exponent: *mut ::libc::c_int) -> ::libc::c_float;
    pub fn __frexpf(__x: ::libc::c_float, __exponent: *mut ::libc::c_int) -> ::libc::c_float;
    pub fn ldexpf(__x: ::libc::c_float, __exponent: ::libc::c_int) -> ::libc::c_float;
    pub fn __ldexpf(__x: ::libc::c_float, __exponent: ::libc::c_int) -> ::libc::c_float;
    pub fn logf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __logf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn log10f(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __log10f(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn modff(__x: ::libc::c_float, __iptr: *mut ::libc::c_float) -> ::libc::c_float;
    pub fn __modff(__x: ::libc::c_float, __iptr: *mut ::libc::c_float) -> ::libc::c_float;
    pub fn expm1f(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __expm1f(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn log1pf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __log1pf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn logbf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __logbf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn exp2f(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __exp2f(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn log2f(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __log2f(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn powf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __powf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn sqrtf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __sqrtf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn hypotf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __hypotf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn cbrtf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __cbrtf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn ceilf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __ceilf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn fabsf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __fabsf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn floorf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __floorf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn fmodf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __fmodf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __isinff(__value: ::libc::c_float) -> ::libc::c_int;
    pub fn __finitef(__value: ::libc::c_float) -> ::libc::c_int;
    pub fn isinff(__value: ::libc::c_float) -> ::libc::c_int;
    pub fn finitef(__value: ::libc::c_float) -> ::libc::c_int;
    pub fn dremf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __dremf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn significandf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __significandf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn copysignf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __copysignf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn nanf(__tagb: *const ::libc::c_char) -> ::libc::c_float;
    pub fn __nanf(__tagb: *const ::libc::c_char) -> ::libc::c_float;
    pub fn __isnanf(__value: ::libc::c_float) -> ::libc::c_int;
    pub fn isnanf(__value: ::libc::c_float) -> ::libc::c_int;
    pub fn j0f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __j0f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn j1f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __j1f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn jnf(arg1: ::libc::c_int, arg2: ::libc::c_float) -> ::libc::c_float;
    pub fn __jnf(arg1: ::libc::c_int, arg2: ::libc::c_float) -> ::libc::c_float;
    pub fn y0f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __y0f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn y1f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __y1f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn ynf(arg1: ::libc::c_int, arg2: ::libc::c_float) -> ::libc::c_float;
    pub fn __ynf(arg1: ::libc::c_int, arg2: ::libc::c_float) -> ::libc::c_float;
    pub fn erff(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __erff(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn erfcf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __erfcf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn lgammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __lgammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn tgammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __tgammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn gammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __gammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn lgammaf_r(arg1: ::libc::c_float, __signgamp: *mut ::libc::c_int) -> ::libc::c_float;
    pub fn __lgammaf_r(arg1: ::libc::c_float, __signgamp: *mut ::libc::c_int) -> ::libc::c_float;
    pub fn rintf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __rintf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn nextafterf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __nextafterf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn nexttowardf(__x: ::libc::c_float, __y: ::libc::c_double) -> ::libc::c_float;
    pub fn __nexttowardf(__x: ::libc::c_float, __y: ::libc::c_double) -> ::libc::c_float;
    pub fn remainderf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __remainderf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn scalbnf(__x: ::libc::c_float, __n: ::libc::c_int) -> ::libc::c_float;
    pub fn __scalbnf(__x: ::libc::c_float, __n: ::libc::c_int) -> ::libc::c_float;
    pub fn ilogbf(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __ilogbf(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn scalblnf(__x: ::libc::c_float, __n: ::libc::c_long) -> ::libc::c_float;
    pub fn __scalblnf(__x: ::libc::c_float, __n: ::libc::c_long) -> ::libc::c_float;
    pub fn nearbyintf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __nearbyintf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn roundf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __roundf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn truncf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn __truncf(__x: ::libc::c_float) -> ::libc::c_float;
    pub fn remquof(__x: ::libc::c_float,
                   __y: ::libc::c_float,
                   __quo: *mut ::libc::c_int)
                   -> ::libc::c_float;
    pub fn __remquof(__x: ::libc::c_float,
                     __y: ::libc::c_float,
                     __quo: *mut ::libc::c_int)
                     -> ::libc::c_float;
    pub fn lrintf(__x: ::libc::c_float) -> ::libc::c_long;
    pub fn __lrintf(__x: ::libc::c_float) -> ::libc::c_long;
    pub fn llrintf(__x: ::libc::c_float) -> ::libc::c_longlong;
    pub fn __llrintf(__x: ::libc::c_float) -> ::libc::c_longlong;
    pub fn lroundf(__x: ::libc::c_float) -> ::libc::c_long;
    pub fn __lroundf(__x: ::libc::c_float) -> ::libc::c_long;
    pub fn llroundf(__x: ::libc::c_float) -> ::libc::c_longlong;
    pub fn __llroundf(__x: ::libc::c_float) -> ::libc::c_longlong;
    pub fn fdimf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __fdimf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn fmaxf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __fmaxf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn fminf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __fminf(__x: ::libc::c_float, __y: ::libc::c_float) -> ::libc::c_float;
    pub fn __fpclassifyf(__value: ::libc::c_float) -> ::libc::c_int;
    pub fn __signbitf(__value: ::libc::c_float) -> ::libc::c_int;
    pub fn fmaf(__x: ::libc::c_float,
                __y: ::libc::c_float,
                __z: ::libc::c_float)
                -> ::libc::c_float;
    pub fn __fmaf(__x: ::libc::c_float,
                  __y: ::libc::c_float,
                  __z: ::libc::c_float)
                  -> ::libc::c_float;
    pub fn scalbf(__x: ::libc::c_float, __n: ::libc::c_float) -> ::libc::c_float;
    pub fn __scalbf(__x: ::libc::c_float, __n: ::libc::c_float) -> ::libc::c_float;
    pub fn acosl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __acosl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn asinl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __asinl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn atanl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __atanl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn atan2l(__y: ::libc::c_double, __x: ::libc::c_double) -> ::libc::c_double;
    pub fn __atan2l(__y: ::libc::c_double, __x: ::libc::c_double) -> ::libc::c_double;
    pub fn cosl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __cosl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn sinl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __sinl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn tanl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __tanl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn coshl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __coshl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn sinhl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __sinhl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn tanhl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __tanhl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn acoshl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __acoshl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn asinhl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __asinhl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn atanhl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __atanhl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn expl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __expl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn frexpl(__x: ::libc::c_double, __exponent: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn __frexpl(__x: ::libc::c_double, __exponent: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn ldexpl(__x: ::libc::c_double, __exponent: ::libc::c_int) -> ::libc::c_double;
    pub fn __ldexpl(__x: ::libc::c_double, __exponent: ::libc::c_int) -> ::libc::c_double;
    pub fn logl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __logl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn log10l(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __log10l(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn modfl(__x: ::libc::c_double, __iptr: *mut ::libc::c_double) -> ::libc::c_double;
    pub fn __modfl(__x: ::libc::c_double, __iptr: *mut ::libc::c_double) -> ::libc::c_double;
    pub fn expm1l(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __expm1l(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn log1pl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __log1pl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn logbl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __logbl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn exp2l(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __exp2l(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn log2l(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __log2l(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn powl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __powl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn sqrtl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __sqrtl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn hypotl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __hypotl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn cbrtl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __cbrtl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn ceill(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __ceill(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn fabsl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __fabsl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn floorl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __floorl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn fmodl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __fmodl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __isinfl(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn __finitel(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn isinfl(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn finitel(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn dreml(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __dreml(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn significandl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __significandl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn copysignl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __copysignl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn nanl(__tagb: *const ::libc::c_char) -> ::libc::c_double;
    pub fn __nanl(__tagb: *const ::libc::c_char) -> ::libc::c_double;
    pub fn __isnanl(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn isnanl(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn j0l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __j0l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn j1l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __j1l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn jnl(arg1: ::libc::c_int, arg2: ::libc::c_double) -> ::libc::c_double;
    pub fn __jnl(arg1: ::libc::c_int, arg2: ::libc::c_double) -> ::libc::c_double;
    pub fn y0l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __y0l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn y1l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __y1l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn ynl(arg1: ::libc::c_int, arg2: ::libc::c_double) -> ::libc::c_double;
    pub fn __ynl(arg1: ::libc::c_int, arg2: ::libc::c_double) -> ::libc::c_double;
    pub fn erfl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __erfl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfcl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __erfcl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lgammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __lgammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tgammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __tgammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn gammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __gammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lgammal_r(arg1: ::libc::c_double, __signgamp: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn __lgammal_r(arg1: ::libc::c_double, __signgamp: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn rintl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __rintl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn nextafterl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __nextafterl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn nexttowardl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __nexttowardl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn remainderl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __remainderl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn scalbnl(__x: ::libc::c_double, __n: ::libc::c_int) -> ::libc::c_double;
    pub fn __scalbnl(__x: ::libc::c_double, __n: ::libc::c_int) -> ::libc::c_double;
    pub fn ilogbl(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __ilogbl(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn scalblnl(__x: ::libc::c_double, __n: ::libc::c_long) -> ::libc::c_double;
    pub fn __scalblnl(__x: ::libc::c_double, __n: ::libc::c_long) -> ::libc::c_double;
    pub fn nearbyintl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __nearbyintl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn roundl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __roundl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn truncl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn __truncl(__x: ::libc::c_double) -> ::libc::c_double;
    pub fn remquol(__x: ::libc::c_double,
                   __y: ::libc::c_double,
                   __quo: *mut ::libc::c_int)
                   -> ::libc::c_double;
    pub fn __remquol(__x: ::libc::c_double,
                     __y: ::libc::c_double,
                     __quo: *mut ::libc::c_int)
                     -> ::libc::c_double;
    pub fn lrintl(__x: ::libc::c_double) -> ::libc::c_long;
    pub fn __lrintl(__x: ::libc::c_double) -> ::libc::c_long;
    pub fn llrintl(__x: ::libc::c_double) -> ::libc::c_longlong;
    pub fn __llrintl(__x: ::libc::c_double) -> ::libc::c_longlong;
    pub fn lroundl(__x: ::libc::c_double) -> ::libc::c_long;
    pub fn __lroundl(__x: ::libc::c_double) -> ::libc::c_long;
    pub fn llroundl(__x: ::libc::c_double) -> ::libc::c_longlong;
    pub fn __llroundl(__x: ::libc::c_double) -> ::libc::c_longlong;
    pub fn fdiml(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __fdiml(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn fmaxl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __fmaxl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn fminl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __fminl(__x: ::libc::c_double, __y: ::libc::c_double) -> ::libc::c_double;
    pub fn __fpclassifyl(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn __signbitl(__value: ::libc::c_double) -> ::libc::c_int;
    pub fn fmal(__x: ::libc::c_double,
                __y: ::libc::c_double,
                __z: ::libc::c_double)
                -> ::libc::c_double;
    pub fn __fmal(__x: ::libc::c_double,
                  __y: ::libc::c_double,
                  __z: ::libc::c_double)
                  -> ::libc::c_double;
    pub fn scalbl(__x: ::libc::c_double, __n: ::libc::c_double) -> ::libc::c_double;
    pub fn __scalbl(__x: ::libc::c_double, __n: ::libc::c_double) -> ::libc::c_double;
    pub fn matherr(__exc: *mut exception) -> ::libc::c_int;
    pub fn memcpy(__dest: *mut ::libc::c_void,
                  __src: *const ::libc::c_void,
                  __n: size_t)
                  -> *mut ::libc::c_void;
    pub fn memmove(__dest: *mut ::libc::c_void,
                   __src: *const ::libc::c_void,
                   __n: size_t)
                   -> *mut ::libc::c_void;
    pub fn memccpy(__dest: *mut ::libc::c_void,
                   __src: *const ::libc::c_void,
                   __c: ::libc::c_int,
                   __n: size_t)
                   -> *mut ::libc::c_void;
    pub fn memset(__s: *mut ::libc::c_void,
                  __c: ::libc::c_int,
                  __n: size_t)
                  -> *mut ::libc::c_void;
    pub fn memcmp(__s1: *const ::libc::c_void,
                  __s2: *const ::libc::c_void,
                  __n: size_t)
                  -> ::libc::c_int;
    pub fn memchr(__s: *const ::libc::c_void,
                  __c: ::libc::c_int,
                  __n: size_t)
                  -> *mut ::libc::c_void;
    pub fn strcpy(__dest: *mut ::libc::c_char,
                  __src: *const ::libc::c_char)
                  -> *mut ::libc::c_char;
    pub fn strncpy(__dest: *mut ::libc::c_char,
                   __src: *const ::libc::c_char,
                   __n: size_t)
                   -> *mut ::libc::c_char;
    pub fn strcat(__dest: *mut ::libc::c_char,
                  __src: *const ::libc::c_char)
                  -> *mut ::libc::c_char;
    pub fn strncat(__dest: *mut ::libc::c_char,
                   __src: *const ::libc::c_char,
                   __n: size_t)
                   -> *mut ::libc::c_char;
    pub fn strcmp(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
    pub fn strncmp(__s1: *const ::libc::c_char,
                   __s2: *const ::libc::c_char,
                   __n: size_t)
                   -> ::libc::c_int;
    pub fn strcoll(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
    pub fn strxfrm(__dest: *mut ::libc::c_char,
                   __src: *const ::libc::c_char,
                   __n: size_t)
                   -> ::libc::c_ulong;
    pub fn strcoll_l(__s1: *const ::libc::c_char,
                     __s2: *const ::libc::c_char,
                     __l: __locale_t)
                     -> ::libc::c_int;
    pub fn strxfrm_l(__dest: *mut ::libc::c_char,
                     __src: *const ::libc::c_char,
                     __n: size_t,
                     __l: __locale_t)
                     -> size_t;
    pub fn strdup(__s: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn strndup(__string: *const ::libc::c_char, __n: size_t) -> *mut ::libc::c_char;
    pub fn strchr(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn strrchr(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn strcspn(__s: *const ::libc::c_char, __reject: *const ::libc::c_char) -> ::libc::c_ulong;
    pub fn strspn(__s: *const ::libc::c_char, __accept: *const ::libc::c_char) -> ::libc::c_ulong;
    pub fn strpbrk(__s: *const ::libc::c_char,
                   __accept: *const ::libc::c_char)
                   -> *mut ::libc::c_char;
    pub fn strstr(__haystack: *const ::libc::c_char,
                  __needle: *const ::libc::c_char)
                  -> *mut ::libc::c_char;
    pub fn strtok(__s: *mut ::libc::c_char, __delim: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn __strtok_r(__s: *mut ::libc::c_char,
                      __delim: *const ::libc::c_char,
                      __save_ptr: *mut *mut ::libc::c_char)
                      -> *mut ::libc::c_char;
    pub fn strtok_r(__s: *mut ::libc::c_char,
                    __delim: *const ::libc::c_char,
                    __save_ptr: *mut *mut ::libc::c_char)
                    -> *mut ::libc::c_char;
    pub fn strlen(__s: *const ::libc::c_char) -> ::libc::c_ulong;
    pub fn strnlen(__string: *const ::libc::c_char, __maxlen: size_t) -> size_t;
    pub fn strerror(__errnum: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn strerror_r(__errnum: ::libc::c_int,
                      __buf: *mut ::libc::c_char,
                      __buflen: size_t)
                      -> ::libc::c_int;
    pub fn strerror_l(__errnum: ::libc::c_int, __l: __locale_t) -> *mut ::libc::c_char;
    pub fn __bzero(__s: *mut ::libc::c_void, __n: size_t);
    pub fn bcopy(__src: *const ::libc::c_void, __dest: *mut ::libc::c_void, __n: size_t);
    pub fn bzero(__s: *mut ::libc::c_void, __n: size_t);
    pub fn bcmp(__s1: *const ::libc::c_void,
                __s2: *const ::libc::c_void,
                __n: size_t)
                -> ::libc::c_int;
    pub fn index(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn rindex(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn ffs(__i: ::libc::c_int) -> ::libc::c_int;
    pub fn strcasecmp(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
    pub fn strncasecmp(__s1: *const ::libc::c_char,
                       __s2: *const ::libc::c_char,
                       __n: size_t)
                       -> ::libc::c_int;
    pub fn strsep(__stringp: *mut *mut ::libc::c_char,
                  __delim: *const ::libc::c_char)
                  -> *mut ::libc::c_char;
    pub fn strsignal(__sig: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn __stpcpy(__dest: *mut ::libc::c_char,
                    __src: *const ::libc::c_char)
                    -> *mut ::libc::c_char;
    pub fn stpcpy(__dest: *mut ::libc::c_char,
                  __src: *const ::libc::c_char)
                  -> *mut ::libc::c_char;
    pub fn __stpncpy(__dest: *mut ::libc::c_char,
                     __src: *const ::libc::c_char,
                     __n: size_t)
                     -> *mut ::libc::c_char;
    pub fn stpncpy(__dest: *mut ::libc::c_char,
                   __src: *const ::libc::c_char,
                   __n: size_t)
                   -> *mut ::libc::c_char;
    pub fn aiGetImporterDesc(extension: *const ::libc::c_char) -> *const aiImporterDesc;
    pub fn aiImportFile(pFile: *const ::libc::c_char, pFlags: ::libc::c_uint) -> *const aiScene;
    pub fn aiImportFileEx(pFile: *const ::libc::c_char,
                          pFlags: ::libc::c_uint,
                          pFS: *mut aiFileIO)
                          -> *const aiScene;
    pub fn aiImportFileExWithProperties(pFile: *const ::libc::c_char,
                                        pFlags: ::libc::c_uint,
                                        pFS: *mut aiFileIO,
                                        pProps: *const aiPropertyStore)
                                        -> *const aiScene;
    pub fn aiImportFileFromMemory(pBuffer: *const ::libc::c_char,
                                  pLength: ::libc::c_uint,
                                  pFlags: ::libc::c_uint,
                                  pHint: *const ::libc::c_char)
                                  -> *const aiScene;
    pub fn aiImportFileFromMemoryWithProperties(pBuffer: *const ::libc::c_char,
                                                pLength: ::libc::c_uint,
                                                pFlags: ::libc::c_uint,
                                                pHint: *const ::libc::c_char,
                                                pProps: *const aiPropertyStore)
                                                -> *const aiScene;
    pub fn aiApplyPostProcessing(pScene: *const aiScene, pFlags: ::libc::c_uint) -> *const aiScene;
    pub fn aiGetPredefinedLogStream(pStreams: aiDefaultLogStream,
                                    file: *const ::libc::c_char)
                                    -> aiLogStream;
    pub fn aiAttachLogStream(stream: *const aiLogStream);
    pub fn aiEnableVerboseLogging(d: aiBool);
    pub fn aiDetachLogStream(stream: *const aiLogStream) -> aiReturn;
    pub fn aiDetachAllLogStreams();
    pub fn aiReleaseImport(pScene: *const aiScene);
    pub fn aiGetErrorString() -> *const ::libc::c_char;
    pub fn aiIsExtensionSupported(szExtension: *const ::libc::c_char) -> aiBool;
    pub fn aiGetExtensionList(szOut: *mut aiString);
    pub fn aiGetMemoryRequirements(pIn: *const aiScene, in_: *mut aiMemoryInfo);
    pub fn aiCreatePropertyStore() -> *mut aiPropertyStore;
    pub fn aiReleasePropertyStore(p: *mut aiPropertyStore);
    pub fn aiSetImportPropertyInteger(store: *mut aiPropertyStore,
                                      szName: *const ::libc::c_char,
                                      value: ::libc::c_int);
    pub fn aiSetImportPropertyFloat(store: *mut aiPropertyStore,
                                    szName: *const ::libc::c_char,
                                    value: ::libc::c_float);
    pub fn aiSetImportPropertyString(store: *mut aiPropertyStore,
                                     szName: *const ::libc::c_char,
                                     st: *const aiString);
    pub fn aiSetImportPropertyMatrix(store: *mut aiPropertyStore,
                                     szName: *const ::libc::c_char,
                                     mat: *const aiMatrix4x4);
    pub fn aiCreateQuaternionFromMatrix(quat: *mut aiQuaternion, mat: *const aiMatrix3x3);
    pub fn aiDecomposeMatrix(mat: *const aiMatrix4x4,
                             scaling: *mut aiVector3D,
                             rotation: *mut aiQuaternion,
                             position: *mut aiVector3D);
    pub fn aiTransposeMatrix4(mat: *mut aiMatrix4x4);
    pub fn aiTransposeMatrix3(mat: *mut aiMatrix3x3);
    pub fn aiTransformVecByMatrix3(vec: *mut aiVector3D, mat: *const aiMatrix3x3);
    pub fn aiTransformVecByMatrix4(vec: *mut aiVector3D, mat: *const aiMatrix4x4);
    pub fn aiMultiplyMatrix4(dst: *mut aiMatrix4x4, src: *const aiMatrix4x4);
    pub fn aiMultiplyMatrix3(dst: *mut aiMatrix3x3, src: *const aiMatrix3x3);
    pub fn aiIdentityMatrix3(mat: *mut aiMatrix3x3);
    pub fn aiIdentityMatrix4(mat: *mut aiMatrix4x4);
    pub fn aiGetImportFormatCount() -> size_t;
    pub fn aiGetImportFormatDescription(pIndex: size_t) -> *const aiImporterDesc;
    pub fn aiGetExportFormatCount() -> size_t;
    pub fn aiGetExportFormatDescription(pIndex: size_t) -> *const aiExportFormatDesc;
    pub fn aiReleaseExportFormatDescription(desc: *const aiExportFormatDesc);
    pub fn aiCopyScene(pIn: *const aiScene, pOut: *mut *mut aiScene);
    pub fn aiFreeScene(pIn: *const aiScene);
    pub fn aiExportScene(pScene: *const aiScene,
                         pFormatId: *const ::libc::c_char,
                         pFileName: *const ::libc::c_char,
                         pPreprocessing: ::libc::c_uint)
                         -> aiReturn;
    pub fn aiExportSceneEx(pScene: *const aiScene,
                           pFormatId: *const ::libc::c_char,
                           pFileName: *const ::libc::c_char,
                           pIO: *mut aiFileIO,
                           pPreprocessing: ::libc::c_uint)
                           -> aiReturn;
    pub fn aiExportSceneToBlob(pScene: *const aiScene,
                               pFormatId: *const ::libc::c_char,
                               pPreprocessing: ::libc::c_uint)
                               -> *const aiExportDataBlob;
    pub fn aiReleaseExportBlob(pData: *const aiExportDataBlob);
    pub fn aiGetMaterialProperty(pMat: *const aiMaterial,
                                 pKey: *const ::libc::c_char,
                                 type_: ::libc::c_uint,
                                 index: ::libc::c_uint,
                                 pPropOut: *mut *const aiMaterialProperty)
                                 -> aiReturn;
    pub fn aiGetMaterialFloatArray(pMat: *const aiMaterial,
                                   pKey: *const ::libc::c_char,
                                   type_: ::libc::c_uint,
                                   index: ::libc::c_uint,
                                   pOut: *mut ::libc::c_float,
                                   pMax: *mut ::libc::c_uint)
                                   -> aiReturn;
    pub fn aiGetMaterialIntegerArray(pMat: *const aiMaterial,
                                     pKey: *const ::libc::c_char,
                                     type_: ::libc::c_uint,
                                     index: ::libc::c_uint,
                                     pOut: *mut ::libc::c_int,
                                     pMax: *mut ::libc::c_uint)
                                     -> aiReturn;
    pub fn aiGetMaterialColor(pMat: *const aiMaterial,
                              pKey: *const ::libc::c_char,
                              type_: ::libc::c_uint,
                              index: ::libc::c_uint,
                              pOut: *mut aiColor4D)
                              -> aiReturn;
    pub fn aiGetMaterialUVTransform(pMat: *const aiMaterial,
                                    pKey: *const ::libc::c_char,
                                    type_: ::libc::c_uint,
                                    index: ::libc::c_uint,
                                    pOut: *mut aiUVTransform)
                                    -> aiReturn;
    pub fn aiGetMaterialString(pMat: *const aiMaterial,
                               pKey: *const ::libc::c_char,
                               type_: ::libc::c_uint,
                               index: ::libc::c_uint,
                               pOut: *mut aiString)
                               -> aiReturn;
    pub fn aiGetMaterialTextureCount(pMat: *const aiMaterial,
                                     type_: aiTextureType)
                                     -> ::libc::c_uint;
    pub fn aiGetMaterialTexture(mat: *const aiMaterial,
                                type_: aiTextureType,
                                index: ::libc::c_uint,
                                path: *mut aiString,
                                mapping: *mut aiTextureMapping,
                                uvindex: *mut ::libc::c_uint,
                                blend: *mut ::libc::c_float,
                                op: *mut aiTextureOp,
                                mapmode: *mut aiTextureMapMode,
                                flags: *mut ::libc::c_uint)
                                -> aiReturn;
    pub fn __assert_fail(__assertion: *const ::libc::c_char,
                         __file: *const ::libc::c_char,
                         __line: ::libc::c_uint,
                         __function: *const ::libc::c_char);
    pub fn __assert_perror_fail(__errnum: ::libc::c_int,
                                __file: *const ::libc::c_char,
                                __line: ::libc::c_uint,
                                __function: *const ::libc::c_char);
    pub fn __assert(__assertion: *const ::libc::c_char,
                    __file: *const ::libc::c_char,
                    __line: ::libc::c_int);
}
